buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  

  bus_stop_list ; list of bus stops where the bus will go
  bus_stop_counter   ; ID of where the bus currently is in its schedule
  next ; TODO might be unnecessary 
  number_of_buses
  inbox_length ; length of the inbox
  west ; bus stops in west
  south ; bus stops in south
  east ; bus stops in east
  north; bus stops in north
  central_point ; what is the central point where all buses start from and return to 
  wait_at_central ; whether 
  current_region ; what region is this bus currently covering. 0 = west, 1 = south, 2 = east, 3 = north 

]
 
globals [graph]

to init-buses
  ; Initialize your agents here.

  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  set west [4 5 16 11 17 10 4 3] ; centraal, dam, everts, sloter, lely, suri, leidse, dam, centraal
  set south [4 10 13 7 1 19 23 14 0 22 21 20 3] ; centraal, dam leidse, suriname, haarlem, amstelveense, vu, zuid, rai, amstel, wibaut, weesp, waterloo, centraal]
  set east [20 21 22 0 15 18 15 12 20 3] ; centraal, waterl, weesp, wibaut, amstel, sciencep, uva, sciencep, muider, waterl, centraal
  set north [9 8 6 8 2 8 9 3] ; centraal, hendrik, hasselt, flora, hasselt, buiksloter, hasselt, hendrik, centr
  ;set bs_list [4 5 16 11 17 10 13 7 1 19 23 14 0 15 18 15 12 22 21 20 9 8 2 6 8 9 3]  ; List containing the schedule of the bus in bus_stop IDs (set bs_list n-values 24 [?] doesn't work since not all busstops are adjecent.)
  set bus_stop_counter 0
  set inbox_length 0
  set central_point 3
  set number_of_buses bus_id - 24 + 1 ;number of buses in fleet, add one because of himself
  set wait_at_central true
               
end

to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.
  
  ; add a bus
  if ticks = 10 [
    show "added one bus bc of 10 ticks" 
    let busses n-values 20 [1]
    foreach busses [
      add-bus 3
    ]
  ]
  
  open-inbox
     
   
  if current_stop != -1 [
    ; perform actions at busstop
    at-busstop
  ]
  ; travels to next busstop
  travel-to next
  update-nr-of-buses

end

to at-busstop
    ifelse current_stop = central_point[ 
      ;sets 'next' as the next stop in schedule TODO
      ;set next best-busstop
      drop-off-passengers-at-dam
      send-info
      ;show "at central"
      voting-to-add-bus
      choose-direction
      pick-up-passengers-at-dam
      
    ]
    
    ; if current stop is not the central point
    [
      drop-off-passengers
      pick-up-passengers
      send-info        
    ]
    ; should be done independently of busstop
    set-next-busstop
end

; drop off all passengers regardless of their destination when at dam
to drop-off-passengers-at-dam
  
  foreach bus_passengers [
    let passenger_id item 0 ?
    let destination item 1 ?
    drop-off-passenger passenger_id
  ]
end

; drop off passengers with the right destination when not at central point
to drop-off-passengers
  
  foreach bus_passengers [
    
    let passenger_id item 0 ?
    let destination item 1 ?
    ; if the passenger arrived at its destination or if the current_stop is the central point
    if destination = current_stop[
      drop-off-passenger passenger_id
      ;print "dropped off passenger:"
      ;print ?
    ]
  ]
end
 
; if at central point, picks up passengers with destination within the newly chosen region 
to pick-up-passengers-at-dam
  
  let pas_list get-passengers-at-stop current_stop
  foreach pas_list [
    let passenger_id item 0 ?
    let destination item 1 ?
    ; only pick up when bus is not full
    ifelse length bus_passengers != get-max-passengers bus_type [
      ; only pick up if destination is in region
      if member? destination bus_stop_list [
        pick-up-passenger passenger_id
        print "picked up passenger:"
        print ?
      ]
    ]
    [
      ; break out of function and not try to pick up more passengers
      stop
    ]
  ]
end

;if not the central point, picks up all passengers at busstop 
to pick-up-passengers
  let pas_list get-passengers-at-stop current_stop
  foreach pas_list [
    let passenger_id item 0 ?
    ; check if bus is full
    ifelse length bus_passengers != get-max-passengers bus_type[
      pick-up-passenger passenger_id
      ;print "picked up passenger:"
      ;print ?
    ]
    [
      ; break out of function and not try to pick up more passengers
      stop
    ]
  ]
end

; chooses a new region (TODO: and chooses to add a new bus or not)
to choose-direction
  ; choose the direction with most people waiting
  let direction most-people-waiting
  set current_region direction
;  show direction

  
  show "chosen region"
  show current_region
  
  if direction = 0 [
    set bus_stop_list west
  ]
  if direction = 1 [
    set bus_stop_list east
  ]
  if direction = 2 [
    set bus_stop_list south
  ]
  if direction = 3 [
    set bus_stop_list north
  ]
  ; resets the bus stop counter
  set bus_stop_counter 0
end

; sets 'next' as the next stop in schedule
to set-next-busstop
    set next item bus_stop_counter bus_stop_list
    set bus_stop_counter bus_stop_counter + 1
end


; sends information to all other buses
to send-info
   let bus_list n-values number_of_buses [24 + ?]
   foreach bus_list [
     if bus_id != ? [
       ; sends a string combining amount of passengers in bus and next stop
       let messagestart word length bus_passengers " "
       let message word messagestart next
       send-message ? message
     ]
   ]
end

; opens the inbox and reacts to different messages
; A message consists of a list with three parts: [ticks, sender, content]
to open-inbox
  ; check for a new message
  if length inbox > inbox_length [
    ; take out sender and content of the last message
    let last_message last inbox
    let sender item 1 last_message
    let content last last_message
    if content = "vote" [
      ; decide on vote (1 = yes, 0 = no)
      let vote-outcome is-almost-full bus_type
      ; send message to sender with vote outcome
      send-message sender vote-outcome
      set inbox_length length inbox
    ]
  ]
end

to-report get-max-passengers [ bs_type ]  
  if bs_type = 1[
    report 12
  ]
  if bs_type = 2[
    report 60
  ]
  if bs_type = 3[
    report 150
  ]
end

; retrieve best next stop
to-report best-busstop
  let best_busstop 0
  let highest_reward -1000
  
  ; index in for loop
  let i 0
  let reward 0
  ; for each possible busstop calculate the rewardfunction
  foreach item current_stop graph[
    ; retrieve the busstop to be compared
    let compared_busstop item i item current_stop graph
    ; calculate the reward
    set reward reward-function(compared_busstop)
    if reward > highest_reward [
      set highest_reward reward
      set best_busstop compared_busstop
    ]
    set i i + 1
  ]
  report best_busstop
  
end

to-report reward-function [ bus_stop ] 
  let reward 0
  
  ; calculate different features
  let dist get-distance current_stop bus_stop
  let no_of_people_waiting length get-passengers-at-stop bus_stop
  let no_of_people_destination get-no-destinations bus_stop
  
  ; calculate reward
  set reward (- dist + no_of_people_waiting + no_of_people_destination)
  
  ;show "busstop"
  ;show bus_stop
  ;show "reward"
  ;show reward
   
  report reward
end

to-report get-no-destinations [ bus_stop ]
  let counter 0
  foreach bus_passengers [
    if item 1 ? = bus_stop[
      set counter counter + 1
    ]
  ]  
  ;show "counter"
  ;show bus_stop
  ;show counter
  report counter
end  

to update-nr-of-buses 
  set number_of_buses number_of_buses + length leasing_list
end

to vote-for-new-bus
  show "voting.."
  let counter number_of_buses

  let list_of_buses n-values number_of_buses [24 + ?]
  show "list of buses"
  show list_of_buses
  ;let bus_list n-values number_of_buses [24 + ?]
  
  foreach list_of_buses [
    let current_bus ?
    if current_bus != bus_id [
      send-message current_bus "vote"
    show "sent message to vote"
    ]
  ]
  
end

to-report is-almost-full [bs_type]
  let max_passengers get-max-passengers bs_type
  let perc_full (length bus_passengers / max_passengers)
  show "percentage full"
  show perc_full
  ifelse perc_full >= 0.5 [
    report 1
  ] [
  report 0
  ]
end

; report the region with the most people waiting  
to-report most-people-waiting

  let best_region 0
  let most_people 0
  let region_counter 0

  let region_list (list west south east north)


  foreach region_list [
    let amount 0
    let region ?

  ; count the people waiting in this region
    foreach region[
      set amount amount + length get-passengers-at-stop ?
    ]
    if amount > most_people [
      set most_people amount
      set best_region region_counter
    ]
    
    ;show "at busstop"
    ;show region_counter
    ;show "amount waiting"
    ;show amount
    
    set region_counter region_counter + 1
  ]
  report best_region
end


; report the region with the most people traveling destinations
to-report most-destination-region
  let pass get-passengers-at-stop central_point
  let amount_east 0  
  let amount_north 0
  let amount_west 0
  let amount_south 0
  foreach pass [
    let destination item 1 ?
    if member? destination east [
      set amount_east amount_east + 1
    ]
    if member? destination north [
      set amount_north amount_north + 1
    ]
    if member? destination west [
      set amount_west amount_west + 1
    ]
    if member? destination south [
      set amount_south amount_south + 1
    ]
  ]
  ; get the argmax of all the amounts of people going to a region
  let highest -1
  let most_destination_region "dummy"
  let region 0
  ; 0 = west, 1 = south, 2 = east, 3 = north
  foreach (list amount_west amount_south amount_east amount_north) [
    if highest < ? [
      set highest ?
      set most_destination_region region
    ]
  set region region + 1
  
;  show " amount in region"
;  show ?
;  show "highest"
;  show highest
;  show "most_destination_region"
;  show most_destination_region
  ]
  report most_destination_region
end


to-report get-voting-outcome
  ; check for a new message
  let old_inbox_length inbox_length
  let number_of_votes length inbox - old_inbox_length
  let count_votes 0
  ;for each message in inbox
  let message_list n-values number_of_votes [?]
  foreach message_list [
    ;set message to the next item in the inbox and content to the last item in the message
    let message item (old_inbox_length + ?) inbox
    let content last message
    ;check the content, if 1 increase the votes
    if content = 1 [set count_votes count_votes + 1]
  ]
  
  set inbox_length length inbox
  ;check the total voting outcome
  let vote_outcome (count_votes / number_of_buses)
  let treshold 0.5
  show "voting outcome"
  ifelse vote_outcome > treshold [
    show vote_outcome
    show "new bus"
    report 1
  ] [ 
  show vote_outcome
  show "no new bus"
  report 0 
  ]

end

to voting-to-add-bus
  ifelse wait_at_central = true [
      show "first round, wait at central = true"
      vote-for-new-bus
      set wait_at_central false
    ]
    ;ELSE if second tick bus needs to get voting outcome and choose direction
    [
      show "SECOND round, wait at central = false"
      let lease_new_bus get-voting-outcome
      if lease_new_bus = 1 [
        add-bus 1
      ]
      set wait_at_central true
    ]
end


























  