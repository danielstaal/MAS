;---------------------------------
; code written by DaniÃ«l Staal, Cindy Allis & Sierk Kanis
;---------------------------------

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).
  
  bus_stop_list ; list of bus stops where the bus will go
  bus_stop_counter   ; ID of where the bus currently is in its schedule
  next ; TODO might be unnecessary 
  number_of_buses
  inbox_length ; length of the inbox
  west ; bus stops in west
  south ; bus stops in south
  east ; bus stops in east
  north; bus stops in north
  central_point ; what is the central point where all buses start from and return to 
  wait_at_central ; whether 
  current_region ; what region is this bus currently covering. 0 = west, 1 = south, 2 = east, 3 = north
  last_region  ; the region the bus was traveling before
  buses_per_region ; list of the amount of buses per region, without itself
]
 
globals [graph]

to init-buses
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  set west [4 5 16 11 17 10 4 3] ; centraal, dam, everts, sloter, lely, suri, leidse, dam, centraal
  set south [4 10 13 7 1 19 23 14 0 22 21 20 3] ; centraal, dam leidse, suriname, haarlem, amstelveense, vu, zuid, rai, amstel, wibaut, weesp, waterloo, centraal]
  set east [20 21 22 0 15 18 15 12 20 3] ; centraal, waterl, weesp, wibaut, amstel, sciencep, uva, sciencep, muider, waterl, centraal
  set north [9 8 6 8 2 8 9 3] ; centraal, hendrik, hasselt, flora, hasselt, buiksloter, hasselt, hendrik, centr
  ;set bs_list [4 5 16 11 17 10 13 7 1 19 23 14 0 15 18 15 12 22 21 20 9 8 2 6 8 9 3]  ; List containing the schedule of the bus in bus_stop IDs (set bs_list n-values 24 [?] doesn't work since not all busstops are adjecent.)
  set bus_stop_counter 0
  set inbox_length 0
  set central_point 3
  set number_of_buses bus_id - 24 + 1 ;number of buses in fleet, add one because of himself
  set wait_at_central true
  set buses_per_region [0 0 0 0]
  set last_region 5 ; 5 is the default value if it doesn't have a region yet.
  set current_region 5
  send-info-when-added ; sends all buses that a new bus has been added             
end

; ------------------- main functions --------------------------

; gets executed each tick for every bus seperately
to execute-actions
  ; add starting buses
  if ticks = 10 [
    show "added one bus bc of 10 ticks" 
    let busses n-values 100 [1]
    foreach busses [
      add-bus 3
    ]
  ]
  ; opens the inbox every tick and decides what to do based on the first word in the message
  open-inbox
  ; perform all actions that should be done when at a busstop
  if current_stop != -1 [
    at-busstop
  ]
  ; travels to next busstop
  travel-to next
end

to at-busstop
   ; if current stop is the central point
    ifelse current_stop = central_point[ 
      drop-off-passengers-at-dam
     ; voting-to-add-bus
      choose-direction
      ; sends direction to everyone
      send-info-at-dam
      pick-up-passengers-at-dam
    ] 
    ; if current stop is not the central point
    [
      drop-off-passengers
      pick-up-passengers      
    ]
    ; if task is independently of busstop
    set-next-busstop
end

; ------------------- pick up and drop off functions --------------------------

; drop off all passengers regardless of their destination when at dam
to drop-off-passengers-at-dam
  foreach bus_passengers [
    let passenger_id item 0 ?
    let destination item 1 ?
    drop-off-passenger passenger_id
  ]
end

; drop off passengers with the right destination when not at central point
to drop-off-passengers
  foreach bus_passengers [
    let passenger_id item 0 ?
    let destination item 1 ?
    ; if the passenger has arrived at its destination
    if destination = current_stop[
      drop-off-passenger passenger_id
    ]
  ]
end
 
; if at central point, picks up passengers with destination within the newly chosen region 
to pick-up-passengers-at-dam
  let pas_list get-passengers-at-stop current_stop
  foreach pas_list [
    let passenger_id item 0 ?
    let destination item 1 ?
    ; only pick up when bus is not full
    ifelse length bus_passengers != get-max-passengers bus_type [
      ; only pick up if destination is in region
      if member? destination bus_stop_list [
        pick-up-passenger passenger_id
      ]
    ]
    [
      ; if bus if full break out of function and stop picking up passengers
      stop
    ]
  ]
end

;if not the central point, picks up all passengers at busstop 
to pick-up-passengers
  let pas_list get-passengers-at-stop current_stop
  foreach pas_list [
    let passenger_id item 0 ?
    ; only pick up when bus is not full
    ifelse length bus_passengers != get-max-passengers bus_type[
      pick-up-passenger passenger_id
    ]
    [
      ; if bus if full break out of function and stop picking up passengers
      stop
    ]
  ]
end

; ------------------- message functions --------------------------

; sends information to all other buses
to send-info-at-dam
   let bus_list n-values number_of_buses [24 + ?]
   foreach bus_list [
     if bus_id != ? [
       ; sends a string with protecol "0" and it's last and current region, example: "031"
       let messagestart word "0" last_region
       let message word messagestart current_region
       ; TODO add Cindy's vote as well.
       send-message ? message
     ]
   ]
end

; sends information to all other buses
to send-info-when-added
   let bus_list n-values number_of_buses [24 + ?]
   foreach bus_list [
     if bus_id != ? [
       ; sends a string with protecol "1" which means a bus is added
       let message "1"
       send-message ? message
     ]
   ]
end

; opens the inbox and reacts to different messages
; A message consists of a list with three parts: [ticks, sender, content]
to open-inbox
  ; check for all new messages
  let amount_of_new_messages length inbox - inbox_length
  let forloop n-values amount_of_new_messages [?]
  foreach forloop [
    ; split up the message in parts
    let message_id inbox_length + ?
    let message item message_id inbox
    let sender item 1 message
    let content last message
    
    if content = "vote" [
      ; decide on vote (1 = yes, 0 = no)
      let vote-outcome is-almost-full bus_type
      ; send message to sender with vote outcome
      send-message sender vote-outcome
    ]

    ; for # of buses update
    if item 0 content = "1" [
      set number_of_buses number_of_buses + 1
    ]
    
    ; for # buses per region update
    if item 0 content = "0" [
      let last_reg item 1 content
      let cur_reg item 2 content
      ; decreases the region the bus was traveling in before (if it had a last_region, otherwise 5)
      if read-from-string last_reg != 5 [
        let current_amount item read-from-string last_reg buses_per_region 
        let new_amount current_amount - 1
        set buses_per_region replace-item read-from-string last_reg buses_per_region new_amount
      ]
      ; increases the region the bus is now going to
      let current_amount_cur_reg item read-from-string cur_reg buses_per_region 
      let new_amount_cur_reg current_amount_cur_reg + 1
      set buses_per_region replace-item read-from-string cur_reg buses_per_region new_amount_cur_reg

    ]
  ]
  set inbox_length length inbox
end

; ------------------- choose direction functions --------------------------

; chooses a new region
to choose-direction
  ; gets the best direction according to the reward function 
  let direction direction-reward-function
  ; updates all the concerning variables
  set bus_stop_list item direction (list west south east north)
  set last_region current_region
  set current_region direction
  set bus_stop_counter 0
end

; report # of people waiting per region 
to-report most-people-waiting
  let region_counter 0
  let region_list (list west south east north)
  let waiting_per_region [0 0 0 0]
  foreach region_list [
    let amount 0
    let region ?
    ; count the people waiting at every busstop in this region
    foreach region[
      set amount amount + length get-passengers-at-stop ?
    ]
    set waiting_per_region replace-item region_counter waiting_per_region amount 
    set region_counter region_counter + 1
  ]
  report waiting_per_region
end

; report # of people traveling destinations per region
to-report most-destination-region
  let pass get-passengers-at-stop central_point
  let region_list (list west south east north)
  let amount_per_region (list 0 0 0 0)
  foreach pass [
    let destination item 1 ?
    let region_counter 0
    foreach region_list [
      if member? destination ? [
        let amount item region_counter amount_per_region
        let new_amount amount + 1
        set amount_per_region replace-item region_counter amount_per_region new_amount 
      ]
      set region_counter region_counter + 1
    ]
  ]
  report amount_per_region
end

; ------------------- add-bus functions --------------------------

; TODO, everything that has something to do with inbox should be in the 'inbox' function
to-report get-voting-outcome
  ; check for a new message
  let old_inbox_length inbox_length
  let number_of_votes length inbox - old_inbox_length
  let count_votes 0
  ;for each message in inbox
  let message_list n-values number_of_votes [?]
  foreach message_list [
    ;set message to the next item in the inbox and content to the last item in the message
    let message item (old_inbox_length + ?) inbox
    let content last message
    ;check the content, if 1 increase the votes
    if content = 1 [set count_votes count_votes + 1]
  ]
  
  set inbox_length length inbox
  ;check the total voting outcome
  let vote_outcome (count_votes / number_of_buses)
  let treshold 0.5
  show "voting outcome"
  ifelse vote_outcome > treshold [
    ;show vote_outcome
    ;show "new bus"
    report 1
  ] [ 
  ;show vote_outcome
  ;show "no new bus"
  report 0 
  ]

end

to voting-to-add-bus
  ifelse wait_at_central = true [
      ;show "first round, wait at central = true"
      vote-for-new-bus
      set wait_at_central false
    ]
    ;ELSE if second tick bus needs to get voting outcome and choose direction
    [
      ;show "SECOND round, wait at central = false"
      let lease_new_bus get-voting-outcome
      if lease_new_bus = 1 [
        add-bus 1
      ]
      set wait_at_central true
    ]
end

; asks all the buses to vote
to vote-for-new-bus
  ;show "voting.."
  let counter number_of_buses

  let list_of_buses n-values number_of_buses [24 + ?]
  ;show "list of buses"
  ;show list_of_buses
  ;let bus_list n-values number_of_buses [24 + ?]
  
  foreach list_of_buses [
    let current_bus ?
    if current_bus != bus_id [
      send-message current_bus "vote"
    ;show "sent message to vote"
    ]
  ]
end

to-report is-almost-full [bs_type]
  let max_passengers get-max-passengers bs_type
  let perc_full (length bus_passengers / max_passengers)
  ;show "percentage full"
  ;show perc_full
  ifelse perc_full >= 0.5 [
    report 1
  ] [
  report 0
  ]
end

; ------------------- value functions --------------------------

; reports back the best direction according to the reward function with the designed weights
to-report direction-reward-function
  let reward_per_region [0 0 0 0]
  
  let destinations most-destination-region
  let people_waiting most-people-waiting
  let w1 3 
  let w2 1 ;there are much more people waiting in the whole region than only at the central point. The buses need to bring people fast, and the people waiting will be picked up anyway i guess.
  let w3 20 ; a value around the capacity of 1 bus
  let forloop n-values length reward_per_region [?]
  foreach forloop [
    let amount_with_destination item ? destinations
    let passengers_waiting_in_region item ? people_waiting
    let amount_of_buses_in_region item ? buses_per_region
    ; reward function
    let reward w1 * amount_with_destination + w2 * passengers_waiting_in_region - w3 * amount_of_buses_in_region
    
    set reward_per_region replace-item ? reward_per_region reward 
  ]
  let best_direction arg-max reward_per_region
  report best_direction
end

; ------------------- helper functions --------------------------

; returns the index of the highest number in a list
to-report arg-max [list1]
  let highest -100000
  let index "dummy"
  let iterator 0
  foreach (list1) [
    if highest < ? [
      set highest ?
      set index iterator
    ]
  set iterator iterator + 1
  ]
  report index
end

; sets 'next' as the next stop in schedule
to set-next-busstop
    set next item bus_stop_counter bus_stop_list
    set bus_stop_counter bus_stop_counter + 1
end

; reports the maximum capacity of given bustype
to-report get-max-passengers [ bs_type ]  
  if bs_type = 1[
    report 12
  ]
  if bs_type = 2[
    report 60
  ]
  if bs_type = 3[
    report 150
  ]
end





















; NOT USED --------

;; uses the leasing_list to see if new buses are added
;to update-nr-of-buses 
;  ; works only when only 1 bus is added
;  set number_of_buses number_of_buses + length leasing_list
;end


;; TODO What does this function do?
;to-report get-no-destinations [ bus_stop ]
;  let counter 0
;  foreach bus_passengers [
;    if item 1 ? = bus_stop[
;      set counter counter + 1
;    ]
;  ]  
;  ;show "counter"
;  ;show bus_stop
;  ;show counter
;  report counter
;end  

; retrieve best next stop
;to-report best-busstop
;  let best_busstop 0
;  let highest_reward -1000
;  
;  ; index in for loop
;  let i 0
;  let reward 0
;  ; for each possible busstop calculate the rewardfunction
;  foreach item current_stop graph[
;    ; retrieve the busstop to be compared
;    let compared_busstop item i item current_stop graph
;    ; calculate the reward
;    set reward reward-function(compared_busstop)
;    if reward > highest_reward [
;      set highest_reward reward
;      set best_busstop compared_busstop
;    ]
;    set i i + 1
;  ]
;  report best_busstop
;  
;end

;to-report reward-function [ bus_stop ] 
;  let reward 0
;  
;  ; calculate different features
;  let dist get-distance current_stop bus_stop
;  let no_of_people_waiting length get-passengers-at-stop bus_stop
;  let no_of_people_destination get-no-destinations bus_stop
;  
;  ; calculate reward
;  set reward (- dist + no_of_people_waiting + no_of_people_destination)
;
;   
;  report reward
;end